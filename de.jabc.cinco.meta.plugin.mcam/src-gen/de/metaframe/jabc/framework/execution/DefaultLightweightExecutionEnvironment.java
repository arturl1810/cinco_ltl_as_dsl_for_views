/*
 * Copyright 1992,2009 METAFrame Technologies GmbH, Universit√§t Dortmund
 *    _    _    ____   ____     _____                                            _    
 *   (_)  / \  | __ ) / ___|   |  ___| __ __ _ _ __ ___   _____      _____  _ __| | __
 *   | | / _ \ |  _ \| |       | |_ | '__/ _` | '_ ` _ \ / _ \ \ /\ / / _ \| '__| |/ /
 *   | |/ ___ \| |_) | |___    |  _|| | | (_| | | | | | |  __/\ V  V / (_) | |  |   < 
 *  _/ /_/   \_\____/ \____|   |_|  |_|  \__,_|_| |_| |_|\___| \_/\_/ \___/|_|  |_|\_\
 * |__/                                                                             
 *
 * For license details contact nagel@jabc.de
 * 
 */
package de.metaframe.jabc.framework.execution;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import de.metaframe.jabc.framework.execution.context.LightweightExecutionContext;
import de.metaframe.jabc.framework.execution.el.ContextExpressionEvaluator;
import de.metaframe.jabc.framework.execution.el.ContextExpressionEvaluator.FunctionRegistry;
import de.metaframe.jabc.framework.sib.parameter.foundation.ContextExpressionFoundation;

/**
 * This class supports the execution of SIB graph models outside the jABC. It
 * was generated by the Genesys plugin of the jABC and must not be modified.
 * 
 * @author Benjamin Bentmann
 */
public class DefaultLightweightExecutionEnvironment implements
		LightweightExecutionEnvironment {

	/**
	 * The parent environment, will be {@code null} if this is the root environment of an execution, i.e. not an environment of a sub thread.
	 */
	private final LightweightExecutionEnvironment parent;

	/**
	 * The object that caused execution of the associated thread, can be {@code null}.
	 */
	private final Object cause;

	/**
	 * The stack of execution contexts, never {@code null}.
	 */
	private final List<LightweightExecutionContext> contexts = new ArrayList<LightweightExecutionContext>();

	/**
	 * The context expression evaluator, will be {@code null} until requested. Lazy initialization is crucial here to avoid unnecessary runtime
	 * dependencies in case context expressions are not used by the execution. Furthermore, this field will be {@code null} if this environment
	 * belongs to a sub thread since the parent environment provides the one and only evaluator for the execution.
	 */
	private ContextExpressionEvaluator evaluator;

	/**
	 * The exit branches of the sub threads that were most recently forked by the
	 * thread associated with this execution environment, never {@code null}.
	 */
	private Map<String, String> threadExitBranches = new HashMap<String, String>();

	/**
	 * Creates a new execution environment with the specified global context.
	 * 
	 * @param globalContext
	 *            The global execution context for this environment, must not be
	 *            {@code null}.
	 */
	public DefaultLightweightExecutionEnvironment(
			final LightweightExecutionContext globalContext) {
		this.parent = null;
		if (globalContext == null) {
			throw new IllegalArgumentException("global context missing");
		}
		this.contexts.add(globalContext);
		this.cause = null;
	}

	/**
	 * Creates a new execution environment with the specified parent environment.
	 * 
	 * @param parent
	 *            The parent execution environment for this environment, must not be
	 *            {@code null}.
	 */
	public DefaultLightweightExecutionEnvironment(
			final LightweightExecutionEnvironment parent) {
		this(parent, (parent != null) ? parent.getLocalContext() : null, null);
	}

	/**
	 * Creates a new execution environment with the specified parent environment.
	 * 
	 * @param parent
	 *            The parent execution environment for this environment, must not be {@code null}.
	 * @param context
	 *            The parent execution context for the context stack of this environment, must not be {@code null}.
	 * @param cause
	 *            The cause for the execution of this thread.
	 */
	public DefaultLightweightExecutionEnvironment(final LightweightExecutionEnvironment parent, final LightweightExecutionContext context,
			final Object cause) {
		if (parent == null) {
			throw new IllegalArgumentException("parent environment missing");
		}
		this.parent = parent;
		if (context == null) {
			throw new IllegalArgumentException("parent context missing");
		}
		this.contexts.add(context.createNewChildContext());
		this.cause = cause;
	}

	/**
	 * {@inheritDoc}
	 */
	public LightweightExecutionContext getLocalContext() {
		return this.contexts.get(this.contexts.size() - 1);
	}

	/**
	 * {@inheritDoc}
	 */
	public LightweightExecutionContext popContext() {
		if (this.contexts.size() <= 1) {
			throw new EmptyStackException();
		}
		return this.contexts.remove(this.contexts.size() - 1);
	}

	/**
	 * {@inheritDoc}
	 */
	public LightweightExecutionContext pushContext(
			final LightweightExecutionContext context) {
		if (context == null) {
			throw new IllegalArgumentException("context missing");
		}
		this.contexts.add(context);
		return context;
	}

	/**
	 * {@inheritDoc}
	 */
	public ContextExpressionEvaluator getExpressionEvaluator() {
		if (this.evaluator == null) {
			/*
			 * NOTE: Usage of reflection is mandatory here to avoid a compile-time dependency on the implementation class. Otherwise, code generated
			 * by a Genesys Pure Generator would always require Commons EL whether it uses context expressions or not.
			 */
			try {
				Class<?> type = Class.forName("de.metaframe.jabc.framework.execution.el." + "LightweightContextExpressionEvaluator");
				Constructor<?> ctor = type.getConstructor(LightweightExecutionEnvironment.class, FunctionRegistry.class);
				FunctionRegistry functions = (this.parent != null) ? this.parent.getExpressionEvaluator().getFunctionRegistry() : null;
				this.evaluator = (ContextExpressionEvaluator) ctor.newInstance(this, functions);
			} catch (Exception e) {
				throw new UnsupportedOperationException("no context expression evaluator available", e);
			}
		}
		return this.evaluator;
	}

	/**
	 * {@inheritDoc}
	 */
	public Object evaluate(final ContextExpressionFoundation expression) {
		return getExpressionEvaluator().evaluate(expression.getExpression(), expression.getClazz());
	}

	/**
	 * {@inheritDoc}
	 */
	public void setThreadExitBranch(String threadIdentifier, String branchName) {
		if (threadIdentifier == null) {
			throw new IllegalArgumentException("thread identifier missing");
		}
		this.threadExitBranches.put(threadIdentifier, branchName);
	}

	/**
	 * {@inheritDoc}
	 */
	public void clearThreadExitBranches() {
		this.threadExitBranches.clear();
	}

	/**
	 * {@inheritDoc}
	 */
	public Map<String, String> getThreadExitBranches() {
		return new HashMap<String, String>(this.threadExitBranches);
	}

	/**
	 * {@inheritDoc}
	 */
	public Object getExecutionCause() {
		return this.cause;
	}

}
