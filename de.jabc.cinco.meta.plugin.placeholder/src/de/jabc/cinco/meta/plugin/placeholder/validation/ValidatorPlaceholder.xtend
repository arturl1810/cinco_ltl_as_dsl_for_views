package de.jabc.cinco.meta.plugin.placeholder.validation

import de.jabc.cinco.meta.plugin.placeholder.Constants
import de.jabc.cinco.meta.plugin.validation.SimpleValidator
import mgl.Annotation
import mgl.ModelElement
import mgl.Node
import mgl.NodeContainer

class ValidatorPlaceholder extends SimpleValidator {

	override getProjectAnnotation() {
		return Constants.PROJECT_ANNOTATION
	}

	override checkContainerWithProjectAnnotation(NodeContainer container) {
		val Iterable<Annotation> annotations = container.annotations.filter[name == Constants.PROJECT_ANNOTATION]
		if (annotations.size == 0) {
			return null
		} else if (annotations.size >= 2) {
			return newError(
				"A object is not supposed to have more than one " + Constants.PROJECT_ANNOTATION + "annotation.");
		}
		val Annotation annotation = container.annotations.filter[name == Constants.PROJECT_ANNOTATION].head
		
		// sequential checks fail on first error/warning
		existMentionedNodesCheck(annotation, container)
		?: mentionedCanBeContainedCheck(annotation, container)
		?: kardinalityE1Check(annotation, container)
		?: PostCreateHookCheck(annotation, container)
		?: PostMoveHookCheck(annotation, container)
	}

	/**
	 * This method checks whether there is the corresponding PostCreateHook annotation for the PostCreateHook generated by the Plugin.
	 * If it is there, the method returns null.
	 * If it is not there, the method returns a warning, that should be shown in the editor. 
	 * @param annotation on which the check is performed  
	 * @param element annotated container 
	 * @return error returned 
	 */
	def PostCreateHookCheck(Annotation annotation, NodeContainer element) {
		for (String nodeName : annotation.value) {
			println("Check " + nodeName)
			val Node node = element.graphModel.getModelElement(nodeName) as Node
			println(" > node: " + node)
			val String hookClassNameIncludingPackage = projectPackage(node) + "." +
				Constants.getPostCreateHookClassName(node)
				
			println(" > hookClassNameIncludingPackage: " + hookClassNameIncludingPackage)
			println(" > check result: " + node.postCreateHookCheck(hookClassNameIncludingPackage))
			
			if (!node.postCreateHookCheck(hookClassNameIncludingPackage)) {
				return newWarning(
					"To use the placeholder annotation you need the corresponding postCreate hook" + " at the Node " +
						node.name + " It should be: @postCreate(\"" + hookClassNameIncludingPackage + "\")");
			}
		}
		return null
	}

	/**
	 * This method checks whether there is the corresponding PostMoveHook annotation for the PostMoveHook generated by the Plugin.
	 * If it is there, the method returns null.
	 * If it is not there, the method returns a warning, that should be shown in the editor. 
	 * @param annotation on which the check is performed  
	 * @param element annotated container 
	 * @return error returned 
	 */
	def PostMoveHookCheck(Annotation annotation, NodeContainer element) {
		for (String nodeName : annotation.value) {
			val Node node = element.graphModel.getModelElement(nodeName) as Node
			val String hookClassNameIncludingPackage = projectPackage(node) + "." +
				Constants.getPostMoveHookClassName(node)
			if (!node.postMoveHookCheck(hookClassNameIncludingPackage)) {
				return newWarning(
					"To use the placeholder annotation you need the corresponding postMove hook" + " at the Node " +
						node.name + " It should be: @postMove(\"" + hookClassNameIncludingPackage + "\")");
			}
		}
		return null
	}

	/**
	 * This method checks whether all Nodes Mentioned in the placeholder annotation exist.
	 * If that is true, the method returns null.
	 * If that is false, the method returns an error, that should be shown in the editor. 
	 * @param annotation on which the check is performed  
	 * @param element annotated container 
	 * @return error returned 
	 */
	def existMentionedNodesCheck(Annotation annotation, NodeContainer element) {
		if (annotation.value.nullOrEmpty) {
			return newError("The annotation needs a value that comprises the node types to be contained.");
		}
		for (String nodeName : annotation.value) {
			if (null === element.graphModel.getModelElement(nodeName) ||
				!(element.graphModel.getModelElement(nodeName) instanceof Node)) {
				return newError(
					"The node " + nodeName + " that is mentioned in the placeholder annotation does not exist.");

			}
		}
		return null;
	}

	/**
	 * This method checks whether all Nodes Mentioned in the placeholder annotation can be contained in the annotated Container.
	 * If that is true, the method returns null.
	 * If that is false, the method returns an error, that should be shown in the editor. 
	 * @param annotation on which the check is performed  
	 * @param element annotated container 
	 * @return error returned 
	 */
	def mentionedCanBeContainedCheck(Annotation annotation, NodeContainer element) {
		for (String nodeName : annotation.value) {
			var boolean found = false
			for (ModelElement child : element.containables) {
				if (child instanceof Node && nodeName.equals(child.name)) {
					found = true
				}
			}
			if (!found) {
				return newError(
					"The node " + nodeName +
						" that is mentioned in the placeholder annotation cannot be contained in the annotated container." +
						"It has to be added to the containableElements of this Container for the placeholder to work properly.");
			}
		}
		return null;
	}

	/**
	 * This method checks whether the annotated Container can just contain a single node.
	 * If that is true, the method returns null.
	 * If that is false, the method returns an error, that should be shown in the editor. 
	 * @param annotation on which the check is performed  
	 * @param element annotated container 
	 * @return error returned 
	 */
	def kardinalityE1Check(Annotation annotation, NodeContainer element) {
		if (element.containableElements.size == 1) {
			val cont = element.containableElements.get(0)
			if ((cont.lowerBound == 0 || cont.lowerBound == 1) && cont.upperBound == 1)
				return null
		}
		return newError('''
			A placeholder may be empty or has to contain exactly one node.
			Define the cardinality as [0,1] or [1,1].
			Specify the node types to be contained.
		''');

	}

	// utility
	def String projectPackage(Node element) {
		return element.getGraphModel().getPackage() + "." + Constants.PROJECT_ANNOTATION + ".hooks"
	}

}
