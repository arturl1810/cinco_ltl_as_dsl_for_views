package de.jabc.cinco.meta.plugin.stack.validation

import de.jabc.cinco.meta.plugin.stack.Constants
import de.jabc.cinco.meta.plugin.validation.SimpleValidator
import mgl.Annotation
import mgl.Node
import mgl.NodeContainer

class ValidatorStack extends SimpleValidator {

	override getProjectAnnotation() {
		return Constants.PROJECT_ANNOTATION
	}

	override checkContainerWithProjectAnnotation(NodeContainer element) {
		val Iterable<Annotation> annotations = element.annotations.filter[name == Constants.PROJECT_ANNOTATION]
		if (annotations.size == 0) {
			return null
		} else if (annotations.size >= 2) {
			return newError(
				"A object is not supposed to have more than one " + Constants.PROJECT_ANNOTATION + "annotation.");
		}
		val Annotation annotation = element.annotations.filter[name == Constants.PROJECT_ANNOTATION].head
		// sequential checks fail on first error/warning
		SelfStackCheck(annotation, element)
		?: PoolCheck(annotation, element)
		?: PostCreateHookCheck(annotation, element)
		?: PostMoveHookCheck(annotation, element)
	}

	/**
	 * This method checks whether there is the corresponding PostCreateHook annotation for the PostCreateHook generated by the Plugin.
	 * If it is there, the method returns null.
	 * If it is not there, the method returns a warning, that should be shown in the editor. 
	 * @param annotation on which the check is performed  
	 * @param element annotated container 
	 * @return error returned 
	 */
	def PostCreateHookCheck(Annotation annotation, NodeContainer element) {
		val String hookClassNameIncludingPackage = Constants.projectPackage(element) + "." +
			Constants.getPostCreateHookClassName(element)
		if (element.postCreateHookCheck(hookClassNameIncludingPackage)) {
			return null;
		}
		return newWarning(
			"To use the stack annotation you need the corresponding postCreate hook." +
				" It should be: @postCreate(\"" + hookClassNameIncludingPackage + "\")");
	}

	/**
	 * This method checks whether there is the corresponding PostMoveHook annotation for the PostMoveHook generated by the Plugin.
	 * If it is there, the method returns null.
	 * If it is not there, the method returns a warning, that should be shown in the editor. 
	 * @param annotation on which the check is performed  
	 * @param element annotated container 
	 * @return error returned 
	 */
	def PostMoveHookCheck(Annotation annotation, NodeContainer element) {
		val String hookClassNameIncludingPackage = Constants.projectPackage(element) + "." +
			Constants.getPostMoveHookClassName(element)
		if (element.postMoveHookCheck(hookClassNameIncludingPackage)) {
			return null
		}
		return newWarning(
			"To use the stack annotation you need the corresponding postMove hook." + " It should be: @postMove(\"" +
				hookClassNameIncludingPackage + "\")");
	}

	/**
	 * This method checks whether element can contain itself.
	 * If that is true, the method returns null.
	 * If that is false, the method returns an error, that should be shown in the editor. 
	 * @param annotation on which the check is performed  
	 * @param element annotated container 
	 * @return error returned 
	 */
	def SelfStackCheck(Annotation annotation, NodeContainer element) {
		if (!element.canContain(element)) {
			return newError("The container " + element.getName() + " has to have itself in its containable Elements for the Annotation \"Stackable\" to work");
		}
		return null;
	}

	/**
	 * This method checks whether all containableElements of element that have the stack annotation can be contained in the parents of element.
	 * If that is true, the method returns null.
	 * If that is false, the method returns an error, that should be shown in the editor. 
	 * @param annotation on which the check is performed  
	 * @param element annotated container 
	 * @return error returned 
	 */
	def PoolCheck(Annotation annotation, NodeContainer element) {
		for (NodeContainer parent : element.getContainingContainers) {
			for (Node child : element.containableNodes.filter[annotations.exists[name == Constants.PROJECT_ANNOTATION]]) {
				if (!parent.canContain(child)) {
					return newWarning(
						"The container " + parent.getName() + " should probably have the Node " + child.getName() +
							" in its containable Elements" + " because " + child.getName() + " can be contained in " +
							element.getName() + " and " + element.getName() + " can be contained in " +
							parent.getName() + ".");
				}
			}
		}
		return null;
	}
}
